/* comp_service_impl.cpp

 Generated by phxrpc_pb2service from comp.proto

*/

#include "comp_service_impl.h"

#include "comp_server_config.h"
#include "comp.pb.h"
#include "phxrpc/file.h"
#include <mutex>
#include <list>
#include "Semaphore.h"
#include "InnerHandle.h"

CompServiceImpl::CompServiceImpl(ServiceArgs_t &app_args,
        phxrpc::UThreadEpollScheduler *worker_uthread_scheduler)
        : args_(app_args), worker_uthread_scheduler_(worker_uthread_scheduler) {
}

CompServiceImpl::~CompServiceImpl() {
}

int CompServiceImpl::PhxMqttConnect(const phxrpc::MqttConnectPb &req, phxrpc::MqttConnackPb *resp) {
    return 0;
}

int CompServiceImpl::PhxMqttPublish(const phxrpc::MqttPublishPb &req, phxrpc::MqttPubackPb *resp) {
    // TODO: process req.content()

    return -1;
}

int CompServiceImpl::PhxMqttDisconnect(const phxrpc::MqttDisconnectPb &req) {
    return 0;
}

int CompServiceImpl::PhxEcho(const google::protobuf::StringValue &req, google::protobuf::StringValue *resp) {
    resp->set_value(req.value());

    return 0;
}
extern std::mutex g_queueMutex;
extern std::list<magna::AppRequest> g_reqQueue;
extern std::map<uint32_t, ReqWaitInfo> g_waitInfoMap;
extern Semaphore g_sema;
int CompServiceImpl::Handle(const magna::AppRequest &req, magna::AppResponse *resp) {
	// 将请求放入队列，发送信号量。 TODO 排队时，运行满意度优先调度算法
	g_queueMutex.lock();
	ReqWaitInfo waitInfo;
	waitInfo.id = req.id();
	waitInfo.queueLength = g_reqQueue.size();
	waitInfo.compLamda = GetLamda();
	waitInfo.queueBegin = phxrpc::Timer::GetSteadyClockMS();
	g_waitInfoMap[req.id()] = waitInfo;

	// 更新lamda的统计队列
	if (g_arriveListForLamda.size() >= 50)
	{
		g_arriveListForLamda.pop_front();
		
	}
	g_arriveListForLamda.push_back(waitInfo.queueBegin);
	
	g_reqQueue.push_back(req);
	g_queueMutex.unlock();
	g_sema.signal();
	return 0;
}

