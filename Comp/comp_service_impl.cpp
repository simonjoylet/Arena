/* comp_service_impl.cpp

 Generated by phxrpc_pb2service from comp.proto

*/

#include "comp_service_impl.h"

#include "comp_server_config.h"
#include "comp.pb.h"
#include "phxrpc/file.h"
#include <mutex>
#include <list>
#include "Semaphore.h"
#include "InnerHandle.h"

CompServiceImpl::CompServiceImpl(ServiceArgs_t &app_args,
        phxrpc::UThreadEpollScheduler *worker_uthread_scheduler)
        : args_(app_args), worker_uthread_scheduler_(worker_uthread_scheduler) {
}

CompServiceImpl::~CompServiceImpl() {
}

int CompServiceImpl::PhxMqttConnect(const phxrpc::MqttConnectPb &req, phxrpc::MqttConnackPb *resp) {
    return 0;
}

int CompServiceImpl::PhxMqttPublish(const phxrpc::MqttPublishPb &req, phxrpc::MqttPubackPb *resp) {
    // TODO: process req.content()

    return -1;
}

int CompServiceImpl::PhxMqttDisconnect(const phxrpc::MqttDisconnectPb &req) {
    return 0;
}

int CompServiceImpl::PhxEcho(const google::protobuf::StringValue &req, google::protobuf::StringValue *resp) {
    resp->set_value(req.value());

    return 0;
}
extern std::mutex g_queueMutex;
extern std::list<magna::AppRequest> g_reqQueue;
extern std::map<uint32_t, ReqWaitInfo> g_waitInfoMap;
extern Semaphore g_sema;
extern uint32_t ARRIVE_ROUND;
extern const double COMP_PROCESS_TIME;
const double NET_TRANS_TIME = 10;
const vector<pair<uint32_t, uint32_t>> g_satisfactionMap = { { 500, 4 }, { 1000, 2 } };

void CutTail()
{
	// 先把队列缩减到一定程度，然后再调度
	const uint32_t MAX_QUEUE_LENGTH = 1000 / (COMP_PROCESS_TIME);
	if (g_reqQueue.size() > MAX_QUEUE_LENGTH)
	{
		for (uint32_t i = 0; i < MAX_QUEUE_LENGTH - g_reqQueue.size(); ++i)
		{
			g_reqQueue.pop_back();
		}
	}

}

void FCFS(const magna::AppRequest &req)
{
	g_reqQueue.push_back(req);
}

void FcfsCutTail(const magna::AppRequest &req)
{
	CutTail();
	FCFS(req);
}

void PQ(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); it++)
	{
		if (it->clienttype() < req.clienttype())
		{
			g_reqQueue.insert(it, req);
			done = true;
			break;
		}
	}
	if (!done)
	{
		g_reqQueue.push_back(req);
	}
}

double GetSatisfaction(double totalTime, uint32_t weight)
{
	if (totalTime <= g_satisfactionMap[0].first)
	{
		return g_satisfactionMap[0].second * weight;
	}
	else if (totalTime <= g_satisfactionMap[1].first)
	{
		return g_satisfactionMap[1].second * weight;
	}
// 	else if (totalTime <= g_satisfactionMap[2].first)
// 	{
// 		return g_satisfactionMap[2].second * weight;
// 	}

	return 0;
}

double GetExpectedProfit(list<magna::AppRequest>::iterator it, double extraTime = 0)
{
	double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
	double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME + extraTime;// 等待时间+处理时间+传输时延+额外时间
	return GetSatisfaction(totalTime, it->clienttype());
	
}
void MinExpectedLoss(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	for (auto it = g_reqQueue.end(); it != g_reqQueue.begin(); )
	{
		magna::AppRequest & tmpReq = *(--it);
		// 计算当前位置到队尾的期望收益
		double profitBefore = 0;
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitBefore += GetExpectedProfit(jt);
		}

		// 计算插入该元素之后的期望收益。
		double profitAfter = 0;
		double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
		double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME;
		profitAfter += GetSatisfaction(totalTime, req.clienttype());
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitAfter += GetExpectedProfit(jt, COMP_PROCESS_TIME); // 之后的每个请求都要增加额外处理时间。
		}
		if (profitBefore > profitAfter)
		{
// 			cout << "--------------before insert: ";
// 			for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
// 			{
// 				cout << it->id() << ", ";
// 			}
// 			cout << endl;
			auto jt = it;
			jt++;
			//printf("jt: %d, it: %d, req: %d\n", jt->id(), it->id(), req.id());
			g_reqQueue.insert(jt, req);
// 			cout << "--------------after insert: ";
// 			for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
// 			{
// 				cout << it->id() << ", ";
// 			}
// 			cout << endl;
			done = true;
			break;
		}
	}
	if (!done)
	{
		g_reqQueue.push_back(req);
	}
// 	cout << "current queue: ";
// 	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
// 	{
// 		cout << it->id() << ", ";
// 	}
// 	cout << endl;
}
void PqMinLoss(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	list<magna::AppRequest>::iterator lowWeightIt = g_reqQueue.begin();
	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); it++)
	{
		if (it->clienttype() < req.clienttype())
		{
			lowWeightIt = it;
			break;
		}
	}

	for (auto it = lowWeightIt; it != g_reqQueue.end(); ++it)
	{
		// 计算当前位置到队尾的期望收益
		double profitBefore = 0;
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitBefore += GetExpectedProfit(jt);
		}

		// 计算插入该元素之后的期望收益。
		double profitAfter = 0;
		double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
		double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME;
		profitAfter += GetSatisfaction(totalTime, req.clienttype());
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitAfter += GetExpectedProfit(jt, COMP_PROCESS_TIME); // 之后的每个请求都要增加额外处理时间。
		}

		// 如果插入之前的收益大于插入之后的收益，则继续向后遍历
		if (profitBefore > profitAfter)
		{
			continue;
		}
		else
		{
			g_reqQueue.insert(it, req);
			done = true;
			break;
		}
	}
	

	if (!done)
	{
		g_reqQueue.push_back(req);
	}
	cout << "pq min loss return\n";
}
int CompServiceImpl::Handle(const magna::AppRequest &req, magna::AppResponse *resp) {
	// 将请求放入队列，发送信号量。 TODO 排队时，运行满意度优先调度算法
	g_queueMutex.lock();
	ReqWaitInfo waitInfo;
	waitInfo.id = req.id();
	waitInfo.queueLength = g_reqQueue.size();
	waitInfo.compLamda = GetLamda();
	waitInfo.queueBegin = phxrpc::Timer::GetSteadyClockMS();
	g_waitInfoMap[req.id()] = waitInfo;

	// 更新lamda的统计队列
	if (g_arriveListForLamda.size() >= ARRIVE_ROUND)
	{
		g_arriveListForLamda.pop_front();
		
	}
	g_arriveListForLamda.push_back(waitInfo.queueBegin);
	
	// 三种算法对比，FCFS，PQ，MinExpectedLoss

	//FCFS(req);
	//MinExpectedLoss(req);
	//PQ(req);
	//PqMinLoss(req);
	FcfsCutTail(req);

	g_queueMutex.unlock();
	g_sema.signal();
	return 0;
}

