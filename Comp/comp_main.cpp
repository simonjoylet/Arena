/* comp_main.cpp

 Generated by phxrpc_pb2server from comp.proto

*/

#include <iostream>
#include <memory>
#include <unistd.h>
#include <signal.h>

#include "phxrpc_comp_dispatcher.h"
#include "comp_service_impl.h"
#include "comp_server_config.h"

#include "phxrpc/rpc.h"
#include "phxrpc/msg.h"
#include "phxrpc/file.h"
#include "../AdminServer/admin_client.h"
#include <thread>
#include "InnerHandle.h"
#include "../SimuClient/simu_client.h"

using namespace std;
void Dispatch(const phxrpc::BaseRequest *request,
              phxrpc::BaseResponse *response,
              phxrpc::DispatcherArgs_t *args) {
    ServiceArgs_t *service_args = (ServiceArgs_t *)(args->service_args);

    CompServiceImpl service(*service_args, args->server_worker_uthread_scheduler);
    CompDispatcher dispatcher(service, args);

    phxrpc::BaseDispatcher<CompDispatcher> base_dispatcher(
            dispatcher, CompDispatcher::GetMqttFuncMap(),
            CompDispatcher::GetURIFuncMap());
    if (!base_dispatcher.Dispatch(request, response)) {
		if (dispatcher.Handle_Post(request, response) < 0)
		{
			response->DispatchErr();
		}
    }
}

void ShowUsage(const char *program) {
    printf("\n");
    printf("Usage: %s [-c <config>] [-d] [-l <log level>] [-v]\n", program);
    printf("\n");

    exit(0);
}


AdminClient * g_adminProxy;
uint32_t g_serviceId = 0;
bool g_hbShouldRun = true;

#include "Semaphore.h"
#include <list>
Semaphore g_sema(0);
std::mutex g_queueMutex;
list<magna::AppRequest> g_reqQueue;
map<uint32_t, ReqWaitInfo> g_waitInfoMap;
SimuClient * g_simuProxy;

uint32_t ARRIVE_ROUND = 10; //过去50个请求计算出的到达率，不足50个时，到达率为0
list<uint64_t> g_arriveListForLamda;

// 测试AdminServer是否可用
bool testAdminEcho()
{
	g_adminProxy = new AdminClient;
	//AdminClient ac;
	google::protobuf::StringValue req;
	google::protobuf::StringValue resp;
	req.set_value("Access AdminServer Success");
	int ret = g_adminProxy->PhxEcho(req, &resp);
	printf("AdminServer.PhxEcho return %d\n", ret);
	printf("resp: {\n%s}\n", resp.DebugString().c_str());
	return ret == 0;
}

int32_t RegisterComponent(string ip, uint16_t port)
{
	// 注册服务组件
	magna::RegisterServiceRequest req;
	magna::RegisterServiceResponse rsp;
	req.mutable_addr()->set_ip(ip);
	req.mutable_addr()->set_port(port);
	req.set_servicename(g_compName);
	int ret = g_adminProxy->RegisterService(req, &rsp);
// 	printf("AdminServer.RegisterService return %d\n", ret);
// 	printf("resp: \n{\n%s\n}\n", rsp.DebugString().c_str());
	if (ret == 0)
	{
		g_serviceId = rsp.serviceid();
		printf("RegisterService succ, serviceId: %d\n", rsp.serviceid());
	}
	return ret;
}

// 心跳线程
void ServiceHb(string ip, uint16_t port)
{
	printf("\nService heatbeat thread start running...\n");
	magna::ServiceHeartbeatRequest req;
	magna::ServiceHeartbeatResponse rsp;
	bool lostAdminServer = false;
	uint32_t adminNonAckCount = 0;
	while (g_hbShouldRun)
	{
		sleep(1);
		int ret = -1;
		if (lostAdminServer)
		{
			ret = RegisterComponent(ip, port);
			if (ret != 0)
			{
				continue;
			}
			lostAdminServer = false;
		}

		req.set_serviceid(g_serviceId);
		req.set_lamda(GetLamda());
		req.set_queuelength(g_reqQueue.size());
		
		ret = g_adminProxy->ServiceHeatbeat(req, &rsp);
		if (0 != ret)
		{
			printf("\n[WARNNING]: ServiceHeartbeat failed\n");
			++adminNonAckCount;
			if (adminNonAckCount > 5)
			{
				lostAdminServer = true;
				printf("\n[ERROR]: AdminServer lost\n");
			}
			continue;
		}
		
		adminNonAckCount = 0;
		if (!rsp.ack())
		{
			printf("\nNode heatbeat response ERROR. msg:%s\n", rsp.msg().c_str());
			if (rsp.msg() == "stop")
			{
				auto func = []()
				{
					while (true)
					{
						sleep(2);
						if (g_reqQueue.empty())
						{
							exit(0);
						}
					}
				};
				new std::thread(func);
			}
		}
		else
		{
			//printf("\n[DEBUG]: Service heartbeat received\n");
		}
	}
	printf("\nNode heatbeat thread stopped...\n");
}

uint32_t GetLamda()
{
	if (g_arriveListForLamda.size() < ARRIVE_ROUND)
	{
		return 0;
	}
	uint32_t lamda = 1000 * ARRIVE_ROUND / (g_arriveListForLamda.back() - g_arriveListForLamda.front());
	printf("lamda: %d, queue size: %d\n", lamda, g_reqQueue.size());
	return lamda;
}

extern double COMP_PROCESS_TIME;
const double NET_TRANS_TIME = 10;
const vector<pair<uint32_t, uint32_t>> g_satisfactionMap = { { 500, 4 }, { 1000, 2 } };

void CutTail()
{
	// 先把队列缩减到一定程度，然后再调度
	const uint32_t MAX_QUEUE_LENGTH = 1000 / (COMP_PROCESS_TIME);
	if (g_reqQueue.size() > MAX_QUEUE_LENGTH)
	{
		for (uint32_t i = 0; i < MAX_QUEUE_LENGTH - g_reqQueue.size(); ++i)
		{
			g_reqQueue.pop_back();
		}
	}

}
void PQ(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); it++)
	{
		if (it->clienttype() < req.clienttype())
		{
			g_reqQueue.insert(it, req);
			done = true;
			break;
		}
	}
	if (!done)
	{
		g_reqQueue.push_back(req);
	}
}
double GetSatisfaction(double totalTime, uint32_t weight)
{
	if (totalTime <= g_satisfactionMap[0].first)
	{
		return g_satisfactionMap[0].second * weight;
	}
	else if (totalTime <= g_satisfactionMap[1].first)
	{
		return g_satisfactionMap[1].second * weight;
	}
	// 	else if (totalTime <= g_satisfactionMap[2].first)
	// 	{
	// 		return g_satisfactionMap[2].second * weight;
	// 	}

	return 0;
}
double GetExpectedProfit(list<magna::AppRequest>::iterator it, double extraTime = 0)
{
	double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
	double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME + extraTime;// 等待时间+处理时间+传输时延+额外时间
	return GetSatisfaction(totalTime, it->clienttype());

}
void MinExpectedLoss(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	for (auto it = g_reqQueue.end(); it != g_reqQueue.begin();)
	{
		magna::AppRequest & tmpReq = *(--it);
		// 计算当前位置到队尾的期望收益
		double profitBefore = 0;
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitBefore += GetExpectedProfit(jt);
		}

		// 计算插入该元素之后的期望收益。
		double profitAfter = 0;
		double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
		double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME;
		profitAfter += GetSatisfaction(totalTime, req.clienttype());
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitAfter += GetExpectedProfit(jt, COMP_PROCESS_TIME); // 之后的每个请求都要增加额外处理时间。
		}
		if (profitBefore > profitAfter)
		{
			// 			cout << "--------------before insert: ";
			// 			for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
			// 			{
			// 				cout << it->id() << ", ";
			// 			}
			// 			cout << endl;
			auto jt = it;
			jt++;
			//printf("jt: %d, it: %d, req: %d\n", jt->id(), it->id(), req.id());
			g_reqQueue.insert(jt, req);
			// 			cout << "--------------after insert: ";
			// 			for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
			// 			{
			// 				cout << it->id() << ", ";
			// 			}
			// 			cout << endl;
			done = true;
			break;
		}
	}
	if (!done)
	{
		g_reqQueue.push_back(req);
	}
	// 	cout << "current queue: ";
	// 	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); ++it)
	// 	{
	// 		cout << it->id() << ", ";
	// 	}
	// 	cout << endl;
}
void PqMinLoss(const magna::AppRequest &req)
{
	printf("MinExpectedLoss req: %d\n", req.id());
	CutTail();
	bool done = false;
	list<magna::AppRequest>::iterator lowWeightIt = g_reqQueue.begin();
	for (auto it = g_reqQueue.begin(); it != g_reqQueue.end(); it++)
	{
		if (it->clienttype() < req.clienttype())
		{
			lowWeightIt = it;
			break;
		}
	}

	for (auto it = lowWeightIt; it != g_reqQueue.end(); ++it)
	{
		// 计算当前位置到队尾的期望收益
		double profitBefore = 0;
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitBefore += GetExpectedProfit(jt);
		}

		// 计算插入该元素之后的期望收益。
		double profitAfter = 0;
		double waitTime = distance(g_reqQueue.begin(), it) * COMP_PROCESS_TIME;
		double totalTime = waitTime + COMP_PROCESS_TIME + NET_TRANS_TIME;
		profitAfter += GetSatisfaction(totalTime, req.clienttype());
		for (auto jt = it; jt != g_reqQueue.end(); ++jt)
		{
			profitAfter += GetExpectedProfit(jt, COMP_PROCESS_TIME); // 之后的每个请求都要增加额外处理时间。
		}

		// 如果插入之前的收益大于插入之后的收益，则继续向后遍历
		if (profitBefore > profitAfter)
		{
			continue;
		}
		else
		{
			g_reqQueue.insert(it, req);
			done = true;
			break;
		}
	}


	if (!done)
	{
		g_reqQueue.push_back(req);
	}
	cout << "pq min loss return\n";
}


void HandleFunc()
{
	while (true)
	{
		g_sema.wait();
		g_queueMutex.lock();
		
		// 执行队列重排算法
		CutTail();
// 		magna::AppRequest lastReq = g_reqQueue.back();
// 		g_reqQueue.pop_back();
		//PQ(lastReq);
		//PqMinLoss(lastReq);


		magna::AppRequest req = g_reqQueue.front();
		g_reqQueue.pop_front();
		g_queueMutex.unlock();
		ReqWaitInfo & waitInfo = g_waitInfoMap[req.id()];
		waitInfo.queueEnd = phxrpc::Timer::GetSteadyClockMS();

		// 处理请求
		static int doneCount = 0;
		magna::AppResponse rsp;
		InnerHandle(req, &rsp);
		printf("doneCount: %d\n", ++doneCount);
	}
}

int main(int argc, char **argv) {
	printf("argc: %d\n", argc);
    const char *config_file{nullptr};
    bool daemonize{false};
    int log_level{-1};
    extern char *optarg;
    int c;
    while (EOF != (c = getopt(argc, argv, "c:vl:d"))) {
        switch (c) {
            case 'c' : config_file = optarg; break;
            case 'd' : daemonize = true; break;
            case 'l' : log_level = atoi(optarg); break;

            case 'v' :
            default: ShowUsage(argv[0]); break;
        }
    }

    if (daemonize) phxrpc::ServerUtils::Daemonize();

    assert(signal(SIGPIPE, SIG_IGN) != SIG_ERR);

    //set customize log/monitor
    //phxrpc::setlog(openlog, closelog, vlog);
    //phxrpc::MonitorFactory::SetFactory(new YourSelfsMonitorFactory());

    if (nullptr == config_file) ShowUsage(argv[0]);

    CompServerConfig config;
    if (!config.Read(config_file)) ShowUsage(argv[0]);

    if (log_level > 0) config.GetHshaServerConfig().SetLogLevel(log_level);

    phxrpc::openlog(argv[0], config.GetHshaServerConfig().GetLogDir(),
            config.GetHshaServerConfig().GetLogLevel());

	// 获取当前组件绑定的IP和端口号
	string bindIP = config.GetHshaServerConfig().GetBindIP();
	uint16_t bindPort = config.GetHshaServerConfig().GetPort();

	// 向AdminServer注册服务
	AdminClient::Init("../AdminServer/admin_client.conf");
	bool adminOK = testAdminEcho();
	if (adminOK)
	{
		RegisterComponent(bindIP, bindPort);
	}

	// 起一个线程向AdminServer更新服务状态。
	std::thread hb(ServiceHb, bindIP, bindPort);
	std::thread handleTh(HandleFunc);

	SimuClient::Init("../SimuClient/simu_client.conf");
	g_simuProxy = new SimuClient();
    ServiceArgs_t service_args;
    service_args.config = &config;

    phxrpc::HshaServer server(config.GetHshaServerConfig(), Dispatch, &service_args);
    server.RunForever();

    phxrpc::closelog();

    return 0;
}

