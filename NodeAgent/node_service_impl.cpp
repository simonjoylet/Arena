/* node_service_impl.cpp

 Generated by phxrpc_pb2service from node.proto

*/

#include "node_service_impl.h"

#include "node_server_config.h"
#include "node.pb.h"
#include "phxrpc/file.h"
#include <sys/types.h>
#include <errno.h>
#include <signal.h>
#include "NodeData.h"

NodeServiceImpl::NodeServiceImpl(ServiceArgs_t &app_args)
    : args_(app_args) {
}

NodeServiceImpl::~NodeServiceImpl() {
}

int NodeServiceImpl::PhxMqttConnect(const phxrpc::MqttConnectPb &req, phxrpc::MqttConnackPb *resp) {
    return 0;
}

int NodeServiceImpl::PhxMqttPublish(const phxrpc::MqttPublishPb &req, phxrpc::MqttPubackPb *resp) {
    // TODO: process req.content()

    return -1;
}

int NodeServiceImpl::PhxMqttDisconnect(const phxrpc::MqttDisconnectPb &req) {
    return 0;
}

int NodeServiceImpl::PhxEcho(const google::protobuf::StringValue &req, google::protobuf::StringValue *resp) {
    resp->set_value(req.value());

    return 0;
}

int NodeServiceImpl::StartComponent(const magna::StartComponentRequest &req, magna::StartComponentResponse *resp) {
	// 生成配置文件
	const char * confTemplate = "[Server]\nBindIP = %s\nPort = %d\nMaxThreads = 8\nIOThreadCount = 3\n\
PackageName = magna\nMaxConnections = 800000\nMaxQueueLength = 20480\nFastRejectThresholdMS = 20\n\
FastRejectAdjustRate = 5\n\n[Log]\nLogDir = ~/log\nLogLevel = 3\n\n[ServerTimeout]\nSocketTimeoutMS = 5000";
	char contentBuf[512] = {};
	char fileName[16] = {};
	NodeData * nd = NodeData::GetInstance();
	uint16_t compPort = nd->GetNewCompPort();
	sprintf(contentBuf, confTemplate, nd->m_ip.c_str(), compPort);
	sprintf(fileName, "%d.conf", compPort);
	FILE * confFile = fopen(fileName, "wt");
	fwrite(contentBuf, strlen(contentBuf), 1, confFile);
	fclose(confFile);

	char finalParam[128] = {};
	char currentPath[128] = {};
	getcwd(currentPath, sizeof(currentPath));
	sprintf(finalParam, "%s/%s", currentPath, fileName);

	pid_t pid = vfork();
	switch (pid)
	{
	case -1:
		printf("\n!!! fork failed\n");
		break;
	case 0:
		execl(req.path().c_str(), req.path().c_str(), "-c", finalParam, NULL);
		if (errno) perror("exec failed");
		_exit(0);
		break;
	default:
		printf("\ncreate process: %d\n", pid);
		resp->set_success(true);
		resp->set_ip(NodeData::GetInstance()->m_ip);
		resp->set_pid(pid);
		break;
	}
	
    return 0;
}

int NodeServiceImpl::StopComponent(const magna::StopComponentRequest &req, magna::StopComponentResponse *resp) {
    
	pid_t pid = req.pid();
	int ret = kill(pid, SIGKILL);
	if (ret)
	{
		perror("kill failed");
		resp->set_success(false);
	}
	else
	{
		printf("kill %d success\n", pid);
		resp->set_success(true);
	}
	
	return 0;
}

