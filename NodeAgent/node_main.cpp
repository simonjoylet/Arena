/* node_main.cpp

 Generated by phxrpc_pb2server from node.proto

*/

#include <iostream>
#include <memory>
#include <unistd.h>
#include <signal.h>

#include "phxrpc_node_dispatcher.h"
#include "node_service_impl.h"
#include "node_server_config.h"

#include "phxrpc/rpc.h"
#include "phxrpc/msg.h"
#include "phxrpc/file.h"
#include "../AdminServer/admin_client.h"
#include <thread>
#include "NodeData.h"
#include <sys/epoll.h>
#include <errno.h> 
#include "../SimuClient/simu_client.h"


using namespace std;

void Dispatch(const phxrpc::BaseRequest *request,
              phxrpc::BaseResponse *response,
              phxrpc::DispatcherArgs_t *args) {
    ServiceArgs_t *service_args = (ServiceArgs_t *)(args->service_args);

    NodeServiceImpl service(*service_args);
    NodeDispatcher dispatcher(service, args);

    phxrpc::BaseDispatcher<NodeDispatcher> base_dispatcher(
            dispatcher, NodeDispatcher::GetMqttFuncMap(),
            NodeDispatcher::GetURIFuncMap());
    if (!base_dispatcher.Dispatch(request, response)) {
        response->DispatchErr();
    }
}

void ShowUsage(const char *program) {
    printf("\n");
    printf("Usage: %s [-c <config>] [-d] [-l <log level>] [-v]\n", program);
    printf("\n");

    exit(0);
}

AdminClient * g_adminProxy;
SimuClient * g_simuClient;
bool g_hbShouldRun = true;

void NodeHbFunc()
{
	NodeData * nodeData = NodeData::GetInstance();
	printf("\nNode heatbeat thread start running...\n");
	magna::NodeHeartbeatRequest hbReq;
	magna::NodeHeartbeatResponse hbRsp;
	hbReq.mutable_addr()->set_ip(nodeData->m_ip);
	hbReq.mutable_addr()->set_port(nodeData->m_port);
	magna::ReportLoadRequest reportReq;
	magna::ReportLoadResponse reportRsp;
	reportReq.set_ip(nodeData->m_ip);
	while (g_hbShouldRun)
	{
		sleep(1);
		double cpuLoad = 0;
		double diskLoad = 0;
		// 向SimuClient发送数据，用于压测信息统计
		nodeData->GetLoadData(cpuLoad, diskLoad, 5);//计算最近5秒的均值

		reportReq.set_cpuload(cpuLoad);
		reportReq.set_diskload(diskLoad);
		g_simuClient->ReportLoad(reportReq, &reportRsp);//用于压测


		// 向AdminServer发送心跳报文
		hbReq.mutable_load()->set_cpu(cpuLoad); 
		hbReq.mutable_load()->set_disk(diskLoad); 
		int ret = g_adminProxy->NodeHeatbeat(hbReq, &hbRsp);
		if (0 != ret)
		{
			printf("\nNode heatbeat failed, ret: %d\n", ret);
		}

		if (hbRsp.ack())
		{
			printf("\nNode heatbeat ack received\n");
			// 更新节点数据
		}
		else
		{
			printf("\nNode heatbeat response ERROR. msg:%s\n", hbRsp.msg().c_str());
		}
	}
	printf("\nNode heatbeat thread stopped...\n");
	return;
}

bool testAdminEcho()
{
	google::protobuf::StringValue req;
	google::protobuf::StringValue resp;
	req.set_value("Access AdminServer Success");
	int ret = g_adminProxy->PhxEcho(req, &resp);
	printf("AdminServer.PhxEcho return %d\n", ret);
	printf("resp: {\n%s}\n", resp.DebugString().c_str());
	return ret == 0;
}

void CalcNodeLoad(const string & atopReport, double & cpuLoad, double & diskLoad)
{
	// 获取CPU负载
	int beginPos = atopReport.find("idle");
	
	int endPos = atopReport.find('%', beginPos); 
	if (beginPos == string::npos || endPos == string::npos)
	{
		cout << "----------------------idle Not Found\n";
		return;
	}
	string idleStr = atopReport.substr(beginPos + 4, endPos - beginPos - 4);
	int cpuIdle = atoi(idleStr.c_str());
	const int coreNumber = 4; // cpu核心数量
	cpuLoad = 1.0 * (100 * coreNumber - cpuIdle) / (100 * coreNumber);
	cpuLoad = cpuLoad < 0 ? 0 : cpuLoad;

	// 获取磁盘负载
	beginPos = atopReport.find("PID"); // 以PID为标志找到进程负载字符串
	if (beginPos == string::npos)
	{
		cout << "---------------------PID Not Found\n";
		return;
	}
	string processStr = atopReport.substr(beginPos, atopReport.size() - beginPos);
	char * buf = new char[processStr.size() + 1];
	strcpy(buf, processStr.c_str());
	char * linePtr = strtok(buf, "\n"); // 按行分割
	linePtr = strtok(NULL, "\n");// 不要第一行

	double diskWrite = 0;
	while (linePtr != NULL) {
		string lineStr = linePtr;
		endPos = lineStr.find("/s");
		if (endPos != string::npos)
		{
			beginPos = lineStr.rfind('K', endPos - 2);
			string diskStr = lineStr.substr(beginPos + 1, endPos - beginPos - 2);
			char endChar = lineStr[endPos - 1];
			double kps = 0;
			if (endChar == 'K')
			{
				kps = atof(diskStr.c_str());
			}
			else if (endChar == 'M')
			{
				kps = atof(diskStr.c_str()) * 1024;
			}
			else if (endChar == 'G')
			{
				kps = atof(diskStr.c_str()) * 1024 * 1024;
			}
			diskWrite += kps;
		}


		linePtr = strtok(NULL, "\n");
	}
	delete[] buf;
	const int MAX_DISK_MPS = 200; // 测试发现，机械磁盘每秒最多读200MB
	diskLoad = diskWrite / (MAX_DISK_MPS * 1024) ;
	diskLoad = diskLoad > 1 ? 1 : diskLoad;

	printf("\n[DEBUG]: cpuLoad: %.2f, diskLoad: %.2f\n", cpuLoad, diskLoad);
}



int AtopThreadFunc()
{
	struct epoll_event ev;                     //事件临时变量  
	const int MAXEVENTS = 1024;                //最大事件数  
	struct epoll_event events[MAXEVENTS];      //监听事件数组  
	int ret, pid;
	int pipe_fd[2];
	if ((ret = pipe(pipe_fd)) < 0)
	{
		cout << "create pipe fail:" << ret << ",errno:" << errno << endl;
		return -1;
	}
	ev.data.fd = pipe_fd[0];        //设置监听文件描述符，读端  
	ev.events = EPOLLIN | EPOLLET;    //设置要处理的事件类型  
	int epfd = epoll_create(MAXEVENTS);
	ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipe_fd[0], &ev);
	if (ret != 0)
	{
		cout << "epoll_ctl fail:" << ret << ",errno:" << errno << endl;
		close(pipe_fd[0]);
		close(pipe_fd[1]);
		close(epfd);
		return -1;
	}
	if ((pid = fork()) > 0)
	{
		string atopReport;
		while (g_hbShouldRun)
		{
			int count = epoll_wait(epfd, events, MAXEVENTS, 500);
			if (count == 0)// 超时，处理上一轮的数据
			{
				if (atopReport.empty())
				{
					continue;
				}
				// 处理监控数据，更新到NodeData中
				double cpuLoad = 0;
				double diskLoad = 0;
				CalcNodeLoad(atopReport, cpuLoad, diskLoad);
				NodeData::GetInstance()->UpdateLoadData(cpuLoad, diskLoad);
				
				atopReport.clear();
			}
			char readBuffer[2048] = {};
			for (int i = 0; i < count; i++)
			{
				if ((events[i].data.fd == pipe_fd[0]) && (events[i].events&EPOLLIN))
				{
					read(pipe_fd[0], readBuffer, sizeof(readBuffer));
					atopReport.append(readBuffer);
					//printf("%s", readBuffer);
				}
			}
		}
		
		close(pipe_fd[1]);
		close(pipe_fd[0]);
		close(epfd);
		cout << "parent close read pipe" << endl;

	}
	else if (pid == 0)
	{
		close(pipe_fd[0]);//关闭读端
		if (dup2(pipe_fd[1], STDOUT_FILENO) != STDOUT_FILENO)//子进程的输出重定向到管道的输入
		{
			printf("重定向失败！");
			exit(0);
		}
		close(pipe_fd[1]);
		execlp("atop", "atop", "-o", "-1", NULL);
	}

	return 0;
}

int main(int argc, char **argv) {
    const char *config_file{nullptr};
    bool daemonize{false};
    int log_level{-1};
    extern char *optarg;
    int c;
    while (EOF != (c = getopt(argc, argv, "c:vl:d"))) {
        switch (c) {
            case 'c' : config_file = optarg; break;
            case 'd' : daemonize = true; break;
            case 'l' : log_level = atoi(optarg); break;

            case 'v' :
            default: ShowUsage(argv[0]); break;
        }
    }

    if (daemonize) phxrpc::ServerUtils::Daemonize();

    assert(signal(SIGPIPE, SIG_IGN) != SIG_ERR);

    //set customize log/monitor
    //phxrpc::setlog(openlog, closelog, vlog);
    //phxrpc::MonitorFactory::SetFactory(new YourSelfsMonitorFactory());

    if (nullptr == config_file) ShowUsage(argv[0]);

    NodeServerConfig config;
	if (!config.Read(config_file))
	{
		ShowUsage(argv[0]);
	}
	else
	{
		NodeData::GetInstance()->Init(config.GetHshaServerConfig().GetBindIP(), config.GetHshaServerConfig().GetPort());
	}
	

    if (log_level > 0) config.GetHshaServerConfig().SetLogLevel(log_level);

    phxrpc::openlog(argv[0], config.GetHshaServerConfig().GetLogDir(),
            config.GetHshaServerConfig().GetLogLevel());

	// 检查AdminServer是否可用
	AdminClient::Init("../AdminServer/admin_client.conf");
	g_adminProxy = new AdminClient;
	bool adminOK = testAdminEcho();
	if (adminOK)
	{
		// 注册节点
		magna::RegisterNodeRequest req;
		magna::RegisterNodeResponse rsp;
		req.mutable_addr()->set_ip(NodeData::GetInstance()->m_ip);
		req.mutable_addr()->set_port(NodeData::GetInstance()->m_port);
		int ret = g_adminProxy->RegisterNode(req, &rsp);
		printf("AdminServer.RegisterNode return %d\n", ret);
		printf("resp: \n{\n%s\n}\n", rsp.DebugString().c_str());
	}

	// 启动心跳线程
	std::thread hb(NodeHbFunc);

	// 启动atop监控线程
	SimuClient::Init("../SimuClient/simu_client.conf");
	g_simuClient = new SimuClient;
	std::thread atop(AtopThreadFunc);

    ServiceArgs_t service_args;
    service_args.config = &config;

    phxrpc::HshaServer server(config.GetHshaServerConfig(), Dispatch, &service_args);
    server.RunForever();

    phxrpc::closelog();

    return 0;
}

